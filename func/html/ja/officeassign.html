
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>0-1 整数計画</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="officeassign.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit officeassign">エディターで officeassign.m を開く</a></div><div class="right"><a href="matlab:echodemo officeassign">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>0-1 整数計画</h1><!--introduction--><p>このデモでは、オフィス割り当て問題と呼ばれる 0-1 整数計画問題を定式化する方法を示します。次に、BINTPROG を使用してこの問題を解く方法を示します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">オフィス割り当て問題</a></li><li><a href="#2">オフィスのレイアウト</a></li><li><a href="#3">問題の定式化</a></li><li><a href="#6">年功</a></li><li><a href="#7">選好</a></li><li><a href="#9">目的関数</a></li><li><a href="#13">制約</a></li><li><a href="#24">BINTPROG を使用した解決</a></li><li><a href="#30">オプションの変更</a></li></ul></div><h2>オフィス割り当て問題<a name="1"></a></h2><p>Marcelo、Rakesh、Peter、Tom、Marjorie、および Mary Ann の 6 人を 7 つのオフィスに割り当てたいと思います。各オフィスに配置できるのは 1 人だけで、各人は正確に 1 つのオフィスにのみ割り当てられます。これらの人は、オフィスを選ぶことができます。彼らの選好を考慮する際は、年功 (Mathworks に勤務した期間が長いほど、年功が高くなります) が基準とされます。窓のあるオフィスと窓のないオフィスがあります。また、一部の窓は他の窓より大きいです。さらに、Peter と Tom はよく一緒に働いているため、1 つだけ離れたオフィスに配置したいと思います。Marcelo と Rakesh もよく一緒に働いているため、同様にします。</p><h2>オフィスのレイアウト<a name="2"></a></h2><p>オフィス 1、2、3、および 4 は内部オフィス (窓のない) です。オフィス 5、6、および 7 には窓がありますが、オフィス 5 の窓は他の 2 つのオフィスよりも小さいです。ここで、これらのオフィスの配置方法を示します。</p><pre class="codeinput">text(0.1, .73, <span class="string">'office1'</span>);
text(.35, .73, <span class="string">'office2'</span>);
text(.60, .73, <span class="string">'office3'</span>);
text(.82, .73, <span class="string">'office4'</span>);

text(.35, .42, <span class="string">'office5'</span>);
text(.60, .42, <span class="string">'office6'</span>);
text(.82, .42, <span class="string">'office7'</span>);
title(<span class="string">'Office layout:window offices are in the bottom row'</span>);
axis <span class="string">off</span>
set(gcf,<span class="string">'color'</span>,<span class="string">'w'</span>);
</pre><img vspace="5" hspace="5" src="../officeassign_01.png" alt=""> <h2>問題の定式化<a name="3"></a></h2><p>問題の定式化を選択しなければなりません。最初の手順では、問題において解変数 <tt>x</tt> の各要素が表すものを選択します。これは 0-1 整数問題であるため、オフィスに割り当てられる人を各要素が表すようにすることが適切な選択です。社員がオフィスに割り当てられると変数の値が 1 になり 、割り当てられないと 0 になります。各人についての検討は、常に以下の順序で行います。</p><pre>1. Mary Ann
2. Marjorie
3. Tom
4. Peter
5. Marcelo
6. Rakesh</pre><p><tt>x</tt> はベクトルでなければなりません。次に、<tt>x(1)</tt> ～ <tt>x(7)</tt> は、オフィス 1 ～オフィス 7 に割り当てられている Mary Ann に相当します。次の 7 つの要素は、オフィス 1 ～オフィス 7 に割り当てられている Marjorie に相当します (以下、他の人についても同様)。6 人を 7 つのオフィスに割り当てるため、<tt>x</tt> ベクトルの要素は合計で 42 個になります。</p><h2>年功<a name="6"></a></h2><p>MathWorks で勤務している期間が長いほど、選好が重視されるように、年功に基づいて選好に重みを付けたいと思います。年功は以下のようになっています。Mary Ann は 9 年、Marjorie は 10 年、Tom は 5 年、Peter は 3 年、Marcelo は 1.5 年、Rakesh は 2 年です。年功に基づいて、正規化された重みベクトルを作成できます。</p><pre class="codeinput">seniority = [9 10 5 3 1.5 2];
weightvector = seniority/sum(seniority);
</pre><h2>選好<a name="7"></a></h2><p>行がオフィスに対応し、列が人に対応するような選好行列を設定します。各社員の希望は数値で示されています。第一希望のオフィスの数値が最も大きく、すべての数値の合計、つまりその社員の列の合計が 100 になるようにしています。各人の選好が列ベクトルにリストされます。</p><pre class="codeinput">MaryAnn = [0; 0; 0; 0; 10; 40; 50];
Marjorie = [0; 0; 0; 0; 20; 40; 40];
Tom = [0; 0; 0; 0; 30; 40; 30];
Peter = [1; 3; 3; 3; 10; 40; 40];
Marcelo = [3; 4; 1; 2; 10; 40; 40];
Rakesh = [10; 10; 10; 10; 20; 20; 20];

<span class="comment">% The ith element of a person's preference vector is how highly they value</span>
<span class="comment">% the ith office.Thus, the combined preference matrix is:</span>

prefmatrix = [MaryAnn Marjorie Tom Peter Marcelo Rakesh];
</pre><p>年功が列の基準となるように、<tt>weightvector</tt> を使用して選好行列に重みを付けたいと思います。また、この行列を列順にベクトルに変換して、<tt>x</tt> ベクトルに対応するようにすれば、より都合が良いでしょう。</p><pre class="codeinput">PM = prefmatrix * diag(weightvector);
c = PM(:);
</pre><h2>目的関数<a name="9"></a></h2><p>目的は、年功によって重みが付けられた選好の満足度を最大限にすることです。以下は線形目的関数です。</p><pre>     max c'*x</pre><p>これと等価な関数は以下のとおりです。</p><pre>     min -c'*x</pre><h2>制約<a name="13"></a></h2><p>最初の制約セットでは、各人が正確に 1 つのオフィスを得ることが求められます。つまり、各人について、該当する人に対応する <tt>x</tt> 値の合計が正確に 1 であることが求められます。たとえば、2 番目の人である Marjorie の場合、これは <tt>sum(x(8:14))=1</tt> であることを意味します。適切な行列を作成することで、これらの線形制約を等式行列 Aeq と右側のベクトル beq (ここで、<tt>Aeq*x = beq</tt>) で表すことができます。行列 <tt>Aeq</tt> は、1 と 0 で構成されます。たとえば、<tt>Aeq</tt> の 2 番目の行は、正確に 1 つのオフィスを得る Marjorie に対応しており、行は以下のようになります。</p><pre>     0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 ... 0 0 0</pre><p>つまり、列 8 ～ 14 に 7 個の 1 があり、他の列は ゼロです。<tt>Aeq(2,:)*x = 1</tt> は、<tt>sum(x(8:14)) = 1</tt> と等価です。</p><pre class="codeinput">numOffices = 7;
numPeople = 6;
numDim = numOffices * numPeople;
onesvector = ones(1,numOffices);
<span class="comment">% Each row of Aeq corresponds to one person.</span>
Aeq = blkdiag(onesvector,onesvector,onesvector,onesvector, <span class="keyword">...</span>
    onesvector,onesvector);
beq = ones(numPeople,1);
<span class="comment">% View the structure of Aeq, that is, where there are nonzeros (ones)</span>
figure;
spy(Aeq)
set(gcf,<span class="string">'color'</span>,<span class="string">'w'</span>);
set(get(gcf,<span class="string">'CurrentAxes'</span>),<span class="keyword">...</span>
    <span class="string">'PlotBoxAspectRatio'</span>,[43 8 1],<span class="keyword">...</span>
    <span class="string">'YTick'</span>,[1 2 3 4 5 6],<span class="keyword">...</span>
    <span class="string">'YTickLabel'</span>,{<span class="string">'Mary Ann'</span>,<span class="string">'Marjorie'</span>,<span class="string">'Tom'</span>,<span class="string">'Peter'</span>,<span class="string">'Marcelo'</span>,<span class="string">'Rakesh'</span>});
title(<span class="string">'Equality constraints: each person gets exactly one office'</span>)
</pre><img vspace="5" hspace="5" src="../officeassign_02.png" alt=""> <p>第 2 の制約セットは不等式です。 これらの制約では、各オフィスに 1 人だけ配置される (つまり、各オフィスに 1 人がいるか誰もいない) ように指定されます。 これらの制約を取得するために、<tt>A*x &lt;= b</tt> であるような行列 <tt>A</tt> とベクトル <tt>b</tt> を作成します。 行列 <tt>A</tt> と <tt>b</tt> の各行は、オフィスに対応します。したがって、行 1 はオフィス 1 に割り当てられる社員を示します。どの行も一定のパターンで 1 と 0 が並んでいます。行 1 は次のようになります。</p><pre>    1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0  ... 1 0 0 0 0 0 0</pre><p>この後の各行は、これと似ていますが、右に 1 つシフト (循環的に) したものになります。 たとえば、行 3 はオフィス 3 に対応しており、<tt>A(3,:)*x &lt;= 1</tt> (つまり、オフィス 3 には 1 人しか配置できないこと) を示しています。</p><pre class="codeinput">A = repmat(eye(numOffices),1,numPeople);
b = ones(numOffices,1);
<span class="comment">% View the structure of Aeq, that is, where there are nonzeros (ones)</span>
figure;
spy(A)
set(gcf,<span class="string">'color'</span>,<span class="string">'w'</span>);
set(get(gcf,<span class="string">'CurrentAxes'</span>),<span class="keyword">...</span>
    <span class="string">'YTick'</span>,[1 3 5 7],<span class="keyword">...</span>
    <span class="string">'YTickLabel'</span>,{<span class="string">'Office 1'</span>,<span class="string">'Office 3'</span>,<span class="string">'Office 5'</span>,<span class="string">'Office 7'</span>},<span class="keyword">...</span>
    <span class="string">'XTick'</span>,[1 8 15 22 29 36],<span class="keyword">...</span>
    <span class="string">'XTickLabel'</span>,{<span class="string">'Mary Ann'</span>,<span class="string">'Marjorie'</span>,<span class="string">'Tom'</span>,<span class="string">'Peter'</span>,<span class="string">'Marcelo'</span>,<span class="string">'Rakesh'</span>});
title(<span class="string">'Inequality constraints: no more than one person per office'</span>)
</pre><img vspace="5" hspace="5" src="../officeassign_03.png" alt=""> <p>次の制約セットも不等式であるため、それらを、上記からすでに不等式を含んでいる行列 <tt>A</tt> とベクトル <tt>b</tt> に追加します。 Tom と Peter には、1 つだけ離れたオフィスを割り当てたいと思います。Marcelo と Rakesh についても同様です。 まず、彼らの物理的位置に基づき、近似マンハッタン距離を使用して、オフィスの距離行列を作成します。 これは対称行列です。</p><pre class="codeinput">D = zeros(numOffices);
<span class="comment">%   Set up the top right half of the matrix</span>
D(1,2:end) = [1 2 3 2 3 4];
D(2,3:end) = [1 2 1 2 3];
D(3,4:end) = [1 2 1 2];
D(4,5:end) = [3 2 1];
D(5,6:end) = [1 2];
D(6,end)   = 1;
<span class="comment">% The lower left half is the same as the upper right</span>
D = triu(D)' + D;

<span class="comment">% We find the offices that are more than one distance unit away.</span>
[officeA,officeB] = find(D &gt; 1);
numPairs = length(officeA)
</pre><pre class="codeoutput">
numPairs =

    26

</pre><p>これにより、オフィスの <tt>numPairs</tt> ペアが見つかります。これらの <tt>numPairs</tt> に関して、Tom がペアの一方のオフィスを占有している場合、Peter はペアの他方のオフィスを占有できません。そうでなければ、彼らは、2 つ以上離れたオフィスに配置されることになってしまいます。Marcelo と Rakesh についてもこれと同様です。これにより、さらに <tt>2*numPairs</tt> 多い不等式制約が与えられ、これらの制約を <tt>A</tt> と <tt>b</tt> に追加することになります。</p><pre class="codeinput"><span class="comment">% Add enough rows to A to accommodate these constraints.</span>
numrows = 2*numPairs + numOffices;
A((numOffices+1):numrows, 1:numDim) = zeros(2*numPairs,numDim);
</pre><p>numPairs の各オフィス ペア、<tt>officeA</tt> の Tom に対応する <tt>x(i)</tt>、および <tt>OfficeB</tt> の Peter に対応する <tt>x(j)</tt> について、制約は以下のようになります。</p><pre> x(i) + x(j) &lt;= 1</pre><p>つまり、Tom または Peter のいずれかがこれらのオフィスの 1 つを占有できますが、両人とも占有することはできません。</p><pre class="codeinput"><span class="comment">% Tom is person 3 and Peter is person 4</span>
tom = 3;
peter = 4;
<span class="comment">% Marcelo is person 5 and Rakesh is person 6</span>
marcelo = 5;
rakesh = 6;
<span class="comment">% The following anonymous functions return the index in x</span>
<span class="comment">% corresponding to Tom, Peter, Marcelo and Rakesh respectively</span>
<span class="comment">% in office i.</span>
tom_index=@(officenum) (tom-1)*numOffices+officenum;
peter_index=@(officenum) (peter-1)*numOffices+officenum;
marcelo_index=@(officenum) (marcelo-1)*numOffices+officenum;
rakesh_index=@(officenum) (rakesh-1)*numOffices+officenum;

<span class="keyword">for</span> i = 1:numPairs
    tomInOfficeA = tom_index(officeA(i));
    peterInOfficeB = peter_index(officeB(i));
    A(i+numOffices, [tomInOfficeA, peterInOfficeB]) = 1;

    <span class="comment">% Repeat for Marcelo and Rakesh, adding more rows to A and b.</span>
    marceloInOfficeA = marcelo_index(officeA(i));
    rakeshInOfficeB = rakesh_index(officeB(i));
    A(i+numPairs+numOffices, [marceloInOfficeA, rakeshInOfficeB]) = 1;
<span class="keyword">end</span>
b(numOffices+1:numOffices+2*numPairs) = ones(2*numPairs,1);
<span class="comment">% View the structure of the newly added constraints in A, that is,</span>
<span class="comment">%   where there are nonzeros (ones)</span>
figure;
spy( A((numOffices+1):numrows,:) )
set(gcf,<span class="string">'color'</span>,<span class="string">'w'</span>);
title(<span class="string">'Inequality constraints:Tom &amp; Peter nearby; Marcelo &amp; Rakesh nearby'</span>)
</pre><img vspace="5" hspace="5" src="../officeassign_04.png" alt=""> <h2>BINTPROG を使用した解決<a name="24"></a></h2><p>問題の定式化は、以下の線形目的関数で構成されます。</p><pre>   min -c'*x</pre><p>これは、以下の線形制約に従います。</p><pre>   Aeq*x = beq
   A*x &lt;= b</pre><p>これは BINTPROG で期待される形式であるため、これらの行列を BINTPROG に渡すことができます。</p><pre class="codeinput"><span class="comment">% Let BINTPROG choose the start point.</span>
x0 = [];
f = -c;
<span class="comment">% Show the iterative output for each node displayed in the branch and</span>
<span class="comment">% bound algorithm.</span>
options = optimset(<span class="string">'Display'</span>,<span class="string">'iter'</span>,<span class="string">'NodeDisplayInterval'</span>,1);
[x,fval,exitflag,output] = bintprog(f,A,b,Aeq,beq,x0,options);
fval
exitflag
output
<span class="comment">% View the solution to see who got what office.</span>
printofficeassign(x);
title(<span class="string">'Solution for default BranchStrategy and NodeSearchStrategy'</span>);
</pre><pre class="codeoutput">Explored   Obj of LP   Obj of best   Unexplored   Best lower    Relative gap
 nodes    relaxation  integer point     nodes    bound on obj  between bounds
      1       -33.87            -          2          -33.87          -
      2       -32.48            -          3          -33.87          -
*     3       -33.84       -33.84          0          -33.87       0.094%
Optimization terminated.

fval =

  -33.8361


exitflag =

     1


output = 

          iterations: 20
               nodes: 3
                time: 6.3281
           algorithm: 'LP-based branch-and-bound'
      branchStrategy: 'maximum integer infeasibility'
    nodeSrchStrategy: 'best node search'
             message: 'Optimization terminated.'

</pre><img vspace="5" hspace="5" src="../officeassign_05.png" alt=""> <p>この問題の場合、年功による選好の満足度が <tt>-fval</tt> の値まで最大化されます。正の <tt>exitflag</tt> は、BINTPROG が収束したことを示します。この出力構造体により、調べられたノードの数、計算にかかった時間、および LP 緩和サブ問題を解く際に使用された累積反復の回数に関する情報を得ることができます。</p><h2>オプションの変更<a name="30"></a></h2><p>調べられるノードの数、計算にかかる時間、または反復の回数を低減するために、1 組のオプションの変更を試みることができます。BINTPROG では分岐限定アルゴリズムが使用されていますが、オプションを使用して、このアルゴリズムを調整できます。たとえば、既定の分岐法 <tt>[maxinfeas]</tt> では、次に分岐することが不可能な最大の整数の変数 (つまり、値が 0.5 に最も近い変数) を選択します。この分岐法を <tt>[mininfeas]</tt> に設定して問題を再び実行できます。[mininfeas] では、次に分岐することが不可能な最小の整数の変数 (つまり、値が 0 または 1 に最も近いが 0 または 1 に等しくない変数) を選択します。</p><pre class="codeinput"><span class="comment">% Try BranchStrategy = mininfeas</span>
options = optimset(options,<span class="string">'BranchStrategy'</span>,<span class="string">'mininfeas'</span>);
[x,fval,exitflag,output] = bintprog(f,A,b,Aeq,beq,x0,options);
fval
exitflag
output
printofficeassign(x);
title(<span class="string">'Solution for BranchStrategy=mininfeas and default NodeSearchStrategy'</span>);
</pre><pre class="codeoutput">Explored   Obj of LP   Obj of best   Unexplored   Best lower    Relative gap
nodes    relaxation  integer point     nodes    bound on obj  between bounds
      1       -33.87            -          2          -33.87          -
*     2       -33.79       -33.79          1          -33.87        0.24%
      3       -33.86       -33.79          2          -33.87        0.24%
*     4       -33.84       -33.84          1          -33.86       0.071%
Optimization terminated.

fval =

  -33.8361


exitflag =

     1


output = 

          iterations: 21
               nodes: 4
                time: 1.4688
           algorithm: 'LP-based branch-and-bound'
      branchStrategy: 'minimum integer infeasibility'
    nodeSrchStrategy: 'best node search'
             message: 'Optimization terminated.'

</pre><img vspace="5" hspace="5" src="../officeassign_06.png" alt=""> <p>この問題の場合、代替の分岐法によってノード数と反復回数が減らされますが、以前と同じ解は見つけられます。</p><p>最後に、別のノード探索法を選択できます。これは、探索木で次の探索対象ノードを選択するために分岐限定アルゴリズムで使用されるノード探索法です。既定の設定では、最良ノード探索法 <tt>&quot;bn&quot;</tt> を使用して探索が行われます。これは、次に探索される、目的関数の最小の下限を持つノードを選択する探索法です。深度探索法 <tt>&quot;df&quot;</tt> を使用するように、これを変更できます。探索木の各ノードで、木の 1 レベル下にまだ探索されていない子ノードが存在する場合、このアルゴリズムは、その子を選択して探索します。そうでない場合、このアルゴリズムは、木の 1 レベル上のノードに移動し、そのノードから 1 レベル下の子ノードを選択します。</p><pre class="codeinput"><span class="comment">% Try NodeSearchStrategy = df</span>
options = optimset(options,<span class="string">'NodeSearchStrategy'</span>,<span class="string">'df'</span>);
[x,fval,exitflag,output] = bintprog(f,A,b,Aeq,beq,x0,options);
fval
exitflag
output
printofficeassign(x);
title(<span class="string">'Solution for BranchStrategy=mininfeas and NodeSearchStrategy=df'</span>);
</pre><pre class="codeoutput">Explored   Obj of LP   Obj of best   Unexplored   Best lower    Relative gap
nodes    relaxation  integer point     nodes    bound on obj  between bounds
      1       -33.87            -          2          -33.87          -
      2       -33.86            -          3          -33.87          -
      3       -33.84            -          4          -33.87          -
      4       -33.24            -          5          -33.87          -
      5       -32.99            -          6          -33.87          -
      6       -32.99            -          7          -33.87          -
      7       -32.79            -          8          -33.87          -
      8       -32.41            -          9          -33.87          -
      9       -32.18            -         10          -33.87          -
     10       -31.68            -         11          -33.87          -
     11       -31.68            -         12          -33.87          -
     12       -31.35            -         13          -33.87          -
     13       -31.35            -         14          -33.87          -
     14       -31.15            -         15          -33.87          -
     15       -30.74            -         16          -33.87          -
     16       -30.43            -         17          -33.87          -
     17       -30.22            -         18          -33.87          -
     18       -29.68            -         19          -33.87          -
     19       -29.68            -         18          -33.87          -
     20        -21.8            -         19          -33.87          -
     21       -20.98            -         20          -33.87          -
     22       -19.48            -         19          -33.87          -
     23       -20.95            -         18          -33.87          -
     24       -19.64            -         17          -33.87          -
     25       -23.43            -         18          -33.87          -
     26       -21.62            -         19          -33.87          -
     27       -16.12            -         18          -33.87          -
     28       -19.66            -         19          -33.87          -
     29       -19.64            -         18          -33.87          -
     30       -18.16            -         17          -33.87          -
     31       -21.28            -         16          -33.87          -
*    32       -23.77       -23.77         15          -33.87          41%
     33       -22.82       -23.77         14          -33.87          41%
*    34       -24.46       -24.46         13          -33.87          37%
     35       -22.82       -24.46         12          -33.87          37%
     36       -22.82       -24.46         11          -33.87          37%
     37       -24.46       -24.46         10          -33.87          37%
     38       -24.46       -24.46          9          -33.87          37%
*    39       -29.02       -29.02          8          -33.87          16%
     40       -29.34       -29.02          9          -33.87          16%
     41       -25.74       -29.02          8          -33.87          16%
     42       -29.22       -29.02          9          -33.87          16%
     43       -24.03       -29.02          8          -33.87          16%
     44       -22.77       -29.02          7          -33.87          16%
     45        -26.1       -29.02          6          -33.87          16%
*    46       -29.67       -29.67          5          -33.87          14%
     47       -29.42       -29.67          4          -33.87          14%
     48       -29.67       -29.67          3          -33.87          14%
     49       -32.48       -29.67          4          -33.87          14%
     50       -31.77       -29.67          5          -33.87          14%
     51       -31.77       -29.67          6          -33.87          14%
     52       -28.97       -29.67          5          -33.87          14%
     53       -26.05       -29.67          4          -33.87          14%
     54       -28.97       -29.67          3          -33.87          14%
     55       -28.97       -29.67          2          -33.87          14%
*    56       -33.84       -33.84          1          -33.87       0.094%
Optimization terminated.

fval =

  -33.8361


exitflag =

     1


output = 

          iterations: 174
               nodes: 56
                time: 50.9219
           algorithm: 'LP-based branch-and-bound'
      branchStrategy: 'minimum integer infeasibility'
    nodeSrchStrategy: 'depth first search'
             message: 'Optimization terminated.'

</pre><img vspace="5" hspace="5" src="../officeassign_07.png" alt=""> <p>この問題の場合、代替のノード探索法を使用して、ノード数、反復回数、および時間が低減されます。以前と同じ解が見つけられます。</p><p class="footer">Copyright 1990-2006 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Binary Integer Programming % This demo shows how to formulate a binary integer programming problem % called the office assignment problem. It then demonstrates how to solve % the problem using BINTPROG.  %   Copyright 1990-2006 The MathWorks, Inc.  %   $Revision: 1.1.4.12.2.1 $  $Date: 2010/07/29 21:28:56 $  %% Office Assignment Problem % We want to assign 6 people, Marcelo, Rakesh, Peter, Tom, Marjorie, and % Mary Ann, to 7 offices.  Each office can have no more than one person, % and each person gets exactly one office.  The people can give preferences % for the offices, and their preferences are considered based on their % seniority (the longer they have been at the MathWorks, the higher the % seniority). Some offices have windows, some do not, and some windows are % bigger than others. Additionally, Peter and Tom often work together, so % we would like them to be no more than one office away, and Marcelo and % Rakesh often work together so they also should be no more than one office % away.   %% Office Layout % Offices 1, 2, 3, and 4 are inside offices (no windows). Offices 5, 6 and 7 % have windows, but the window in office 5 is smaller than the other two. % Here is how the offices are arranged. text(0.1, .73, 'office1'); text(.35, .73, 'office2'); text(.60, .73, 'office3'); text(.82, .73, 'office4');  text(.35, .42, 'office5'); text(.60, .42, 'office6'); text(.82, .42, 'office7'); title('Office layout: window offices are in the bottom row');  axis off set(gcf,'color','w');  %% Problem Formulation % We need to select our problem formulation. The first step is to choose % what each element of our solution variable |x| represents in % our problem. Since this is a binary integer problem, a good choice is % that each element represents a person assigned to an office. If the % person is assigned to the office, the variable has value 1. If the person % is not assigned to the office, the variable has value 0. We'll consider % the people always in this order:   %% %  1. Mary Ann %  2. Marjorie %  3. Tom %  4. Peter %  5. Marcelo %  6. Rakesh  %% % We need |x| to be a vector. Then |x(1)| to |x(7)| correspond to Mary Ann  % being assigned to office 1, office 2, etc., to office 7. The next 7  % elements correspond to Marjorie being assigned to the seven offices, etc.  % In all, our |x| vector has 42 elements, since we have six people to  % assign to seven offices.  %% Seniority % We will want to weight the preferences based on seniority so that the % longer you have been at the MathWorks, the more your preferences count. % The seniority is as follows: Mary Ann 9 years, Marjorie 10 years, Tom 5 % years, Peter 3 years, Marcelo 1.5 years, and Rakesh 2 years. We can % create a normalized weight vector based on seniority.  seniority = [9 10 5 3 1.5 2]; weightvector = seniority/sum(seniority);  %% Preferences % We set up a preference matrix where the rows correspond to offices and % the columns correspond to people. We ask each person to give values for % each office so that the sum of all their choices, i.e., their column, % sums to 100.  A higher number means the person prefers the office. Each % person's preferences are listed in a column vector.  MaryAnn = [0; 0; 0; 0; 10; 40; 50]; Marjorie = [0; 0; 0; 0; 20; 40; 40]; Tom = [0; 0; 0; 0; 30; 40; 30]; Peter = [1; 3; 3; 3; 10; 40; 40]; Marcelo = [3; 4; 1; 2; 10; 40; 40]; Rakesh = [10; 10; 10; 10; 20; 20; 20];  % The ith element of a person's preference vector is how highly they value % the ith office. Thus, the combined preference matrix is:  prefmatrix = [MaryAnn Marjorie Tom Peter Marcelo Rakesh];  %% % We want to weight the preferences matrix by the |weightvector| to scale the % columns by seniority.  Also, it will be more convenient if we reshape this % matrix as a vector in column-order so that it corresponds to our |x| vector.   PM = prefmatrix * diag(weightvector); c = PM(:);  %% Objective Function % Our objective is to maximize the satisfaction of the preferences weighted % by seniority. This is a linear objective function %% %       max c'*x %% % or equivalently %% %       min -c'*x  %% Constraints % The first set of constraints requires that each person gets exactly one % office, that is for each person, the sum of the |x| values corresponding to % that person is exactly one. For example, since Marjorie is the second % person, this means that |sum(x(8:14))=1|. We can represent these linear % constraints in an equality matrix Aeq and right hand side vector beq, % where |Aeq*x = beq|, by building the appropriate matrices.  The matrix % |Aeq| consists of ones and zeros. For example, the second row of |Aeq| % will correspond to Marjorie getting exactly one office, so the row will  % look like %% %       0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 %% % that is, seven ones in columns 8 through 14 and zeros elsewhere. Then % |Aeq(2,:)*x = 1| is equivalent to |sum(x(8:14)) = 1|. numOffices = 7; numPeople = 6; numDim = numOffices * numPeople; onesvector = ones(1,numOffices); % Each row of Aeq corresponds to one person.  Aeq = blkdiag(onesvector,onesvector,onesvector,onesvector, ...     onesvector,onesvector); beq = ones(numPeople,1); % View the structure of Aeq, that is, where there are nonzeros (ones) figure; spy(Aeq) set(gcf,'color','w'); set(get(gcf,'CurrentAxes'),...     'PlotBoxAspectRatio',[43 8 1],...         'YTick',[1 2 3 4 5 6],...     'YTickLabel',{'Mary Ann','Marjorie','Tom','Peter','Marcelo','Rakesh'});   title('Equality constraints: each person gets exactly one office')  %% % The second set of constraints are inequalities. These constraints specify % that each office has no more than one person in it, i.e., each office  % has one person in it, or is empty. We build the matrix |A| and the vector % |b| such that |A*x <= b| to capture these constraints. Each row of |A| % and |b| corresponds to an office and so row 1 corresponds to people % assigned to office 1.  This time the rows have this type of pattern, for % row 1: %% %      1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0  ... 1 0 0 0 0 0 0 %% % Each row after this is similar but shifted (circularly) to the right by % one spot. For example, row 3 corresponds to office 3 and says that % |A(3,:)*x <= 1|, i.e., office 3 cannot have more than one person in it. A = repmat(eye(numOffices),1,numPeople); b = ones(numOffices,1); % View the structure of Aeq, that is, where there are nonzeros (ones) figure;  spy(A) set(gcf,'color','w'); set(get(gcf,'CurrentAxes'),...     'YTick',[1 3 5 7],...     'YTickLabel',{'Office 1','Office 3','Office 5','Office 7'},...     'XTick',[1 8 15 22 29 36],...     'XTickLabel',{'Mary Ann','Marjorie','Tom','Peter','Marcelo','Rakesh'});   title('Inequality constraints: no more than one person per office')  %% % The next set of constraints are also inequalities, so we will add them to % the matrix |A| and vector |b|, which already contain the inequalities % from above. We want Tom and Peter no more than one office away, and the % same with Marcelo and Rakesh. First we'll build the distance matrix of % the offices based on their physical locations and using approximate  % Manhattan distances. This is a symmetric matrix. D = zeros(numOffices); %   Set up the top right half of the matrix D(1,2:end) = [1 2 3 2 3 4]; D(2,3:end) = [1 2 1 2 3]; D(3,4:end) = [1 2 1 2]; D(4,5:end) = [3 2 1]; D(5,6:end) = [1 2]; D(6,end)   = 1; % The lower left half is the same as the upper right D = triu(D)' + D;  % We find the offices that are more than one distance unit away. [officeA,officeB] = find(D > 1); numPairs = length(officeA)  %% % This finds |numPairs| pairs of offices. For these |numPairs|, if Tom % occupies one office in the pair, then Peter cannot occupy the other % office in the pair, otherwise they will be more than one office away. The % same for Marcelo and Rakesh. This gives |2*numPairs| more inequality % constraints which we will add to |A| and |b|.  % Add enough rows to A to accommodate these constraints. numrows = 2*numPairs + numOffices;  A((numOffices+1):numrows, 1:numDim) = zeros(2*numPairs,numDim);  %% % For each pair of offices in numPairs, for the |x(i)| that corresponds to % Tom in |officeA| and for the |x(j)| that corresponds to Peter in % |OfficeB|,  %% %   x(i) + x(j) <= 1 %% % that is, either Tom or Peter can occupy one of these offices, but they % both cannot.  % Tom is person 3 and Peter is person 4 tom = 3; peter = 4; % Marcelo is person 5 and Rakesh is person 6 marcelo = 5; rakesh = 6; % The following anonymous functions return the index in x  % corresponding to Tom, Peter, Marcelo and Rakesh respectively % in office i. tom_index=@(officenum) (tom-1)*numOffices+officenum; peter_index=@(officenum) (peter-1)*numOffices+officenum; marcelo_index=@(officenum) (marcelo-1)*numOffices+officenum; rakesh_index=@(officenum) (rakesh-1)*numOffices+officenum;  for i = 1:numPairs         tomInOfficeA = tom_index(officeA(i));     peterInOfficeB = peter_index(officeB(i));     A(i+numOffices, [tomInOfficeA, peterInOfficeB]) = 1;         % Repeat for Marcelo and Rakesh, adding more rows to A and b.     marceloInOfficeA = marcelo_index(officeA(i));     rakeshInOfficeB = rakesh_index(officeB(i));     A(i+numPairs+numOffices, [marceloInOfficeA, rakeshInOfficeB]) = 1; end b(numOffices+1:numOffices+2*numPairs) = ones(2*numPairs,1); % View the structure of the newly added constraints in A, that is,  %   where there are nonzeros (ones) figure; spy( A((numOffices+1):numrows,:) ) set(gcf,'color','w'); title('Inequality constraints: Tom & Peter nearby; Marcelo & Rakesh nearby')  %% Solving using BINTPROG % Our problem formulation consists of a linear objective function %% %     min -c'*x %% % subject to the linear constraints %% %     Aeq*x = beq %     A*x <= b %% % As this is the format BINTPROG expects, we can pass these matrices to % BINTPROG.    % Let BINTPROG choose the start point. x0 = []; f = -c; % Show the iterative output for each node displayed in the branch and  % bound algorithm. options = optimset('Display','iter','NodeDisplayInterval',1); [x,fval,exitflag,output] = bintprog(f,A,b,Aeq,beq,x0,options); fval exitflag output % View the solution to see who got what office. printofficeassign(x); title('Solution for default BranchStrategy and NodeSearchStrategy');  %% % For this problem, the satisfaction of the preferences by seniority is % maximized to the value of |-fval|.  A positive |exitflag| tells us that % BINTPROG converged.  The output structure gives us information about % how many nodes were explored, how long the computation took, and how many % cumulative iterations were used in the solving LP relaxations % subproblems.  %% Changing the Options % To reduce the number of nodes explored, the time, or number of iterations % taken, you can try varying a couple of options.  BINTPROG uses a branch % and bound algorithm and we can use the options to adjust that algorithm. % For example, the default branching strategy is |'maxinfeas'|, which says % to choose the variable with the maximum integer infeasibility to branch % on next, that is, the variable whose value is closest to 0.5. We can run % our problem again with the branching strategy set to |'mininfeas'|, which % says to choose the variable with the minimum integer infeasibility to % branch on next, that is, the variable whose value is closest to 0 or 1 % but not equal to 0 or 1.  % Try BranchStrategy = mininfeas options = optimset(options,'BranchStrategy','mininfeas'); [x,fval,exitflag,output] = bintprog(f,A,b,Aeq,beq,x0,options); fval exitflag output printofficeassign(x); title('Solution for BranchStrategy=mininfeas and default NodeSearchStrategy');  %% % For this problem, the number of nodes and iterations are reduced with the % alternate branching strategy, but the same solution is found as before.  %%  % Finally, we can also choose a different node search strategy, i.e., the % strategy the branch-and-bound algorithm uses to select the next node to % search in the search tree. By default, the search is done using the % |'bn'| or best node first search strategy, which chooses the node with % lowest bound on the objective function to search next. We can change this % to use the |'df'| or depth first search strategy. At each node in the % search tree, if there is a child node one level down in the tree that has % not already been explored, the algorithm chooses one such child to % search. Otherwise, the algorithm moves to the node one level up in the % tree and chooses a child node one level down from that node.   % Try NodeSearchStrategy = df options = optimset(options,'NodeSearchStrategy','df'); [x,fval,exitflag,output] = bintprog(f,A,b,Aeq,beq,x0,options); fval exitflag output printofficeassign(x); title('Solution for BranchStrategy=mininfeas and NodeSearchStrategy=df');  %% % For this problem, the number of nodes, iterations, and time are reduced % with the alternate node search strategy. The same solution is found as % before.   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>