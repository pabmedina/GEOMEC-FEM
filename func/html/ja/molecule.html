
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>大規模な制約なし非線形最小化</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="molecule.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit molecule">エディターで molecule.m を開く</a></div><div class="right"><a href="matlab:echodemo molecule">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>大規模な制約なし非線形最小化</h1><!--introduction--><p>このデモでは、Optimization Toolbox™ の大規模アルゴリズムを使用して 2 次元の分子構造問題を解きます。このタイプの問題は、人工衛星の測距や測量といった他のアプリケーションでも生じます。</p><!--/introduction--><p>分子構造問題:分子の N 個の原子を、指定された原子ペア間の距離が実験データと一致するように配置します。</p><p>簡単な例を以下に示します。左側がデータで、右側が解です。</p><pre class="codeinput">load <span class="string">molecule</span>;
[smallI,smallJ,smalldist] = find(smallS);
subplot(1,2,1);
<span class="keyword">for</span> i = 1:length(smalldist)
   line([0,smalldist(i)],[i i]);
   text(-0.07,i,sprintf(<span class="string">'%d'</span>,smallJ(i)));
   text(smalldist(i)+.02,i,sprintf(<span class="string">'%d'</span>,smallI(i)));
<span class="keyword">end</span>
axis([-.1 1 0 10],<span class="string">'off'</span>);
title(<span class="string">'Measured distances between Pairs'</span>);
subplot(1,2,2);
plot(smallsoln(:,1),smallsoln(:,2),<span class="string">'g.'</span>,<span class="string">'MarkerSize'</span>,15);
<span class="keyword">for</span> i = 1:length(smalldist),
   line([smallsoln(smallI(i),1) smallsoln(smallJ(i),1)], <span class="keyword">...</span>
      [smallsoln(smallI(i),2) smallsoln(smallJ(i),2)]);
<span class="keyword">end</span>
textpos = smallsoln + [-.09 0;-.08 .08;.04 .01;.04 0;.03 -.07;.03 .07];
<span class="keyword">for</span> i = 1:6
   text(textpos(i,1),textpos(i,2),sprintf(<span class="string">'%d'</span>,i));
<span class="keyword">end</span>
axis([-0.1 1 0 1.1],<span class="string">'off'</span>,<span class="string">'square'</span>);
title(<span class="string">'Atom Locations'</span>);
</pre><img vspace="5" hspace="5" src="../molecule_01.png" alt=""> <p>この問題に対する最適化アプローチでは、ランダムな構成 (上記) から始めて、最小誤差の構成が見つかるまで原子を移動させます。具体的には、原子の位置が以下のように与えられた場合</p><pre>   X = [x(1:N) y(1:N)]';</pre><p>測定データ S にあるそれぞれの対 (i,j) の誤差を (norm(X(i,:)-X(j,:))^2 - S(i,j)^2)^2 とします。全誤差 MMOLE(X,S) は、S にあるすべての対の誤差の合計です。誤差関数 MMOLE が極小になる値を見つけます。</p><pre class="codeinput">N = 25;
[I,J,dist] = find(S);
Xstart = [ [.25 .25]; [.25 .75]; [.75 .25]; reshape(xstart,N-3,2) ];

subplot(1,1,1);
plot(Xstart(:,1),Xstart(:,2),<span class="string">'g.'</span>,<span class="string">'Markersize'</span>,18);
<span class="keyword">for</span> k = 1:length(dist)
   line([Xstart(I(k),1) Xstart(J(k),1)],[Xstart(I(k),2) Xstart(J(k),2)]);
<span class="keyword">end</span>
title(<span class="string">'Initial Locations'</span>);
axis <span class="string">square</span>;
</pre><img vspace="5" hspace="5" src="../molecule_02.png" alt=""> <p>距離は、剛体運動の下では不変です。平行移動、回転、および反射は、誤差関数 MMOLE に影響しません。</p><p>このような動きを避けるために、3 つの原子位置が既知であると仮定します。これらの位置は固定されているため、実際には 2N-6 個の不明な位置のみを扱うことになります。</p><pre class="codeinput"><span class="comment">% First illustration.</span>
subplot(2,2,1);
plot(smallsoln(:,1),smallsoln(:,2),<span class="string">'g.'</span>,<span class="string">'MarkerSize'</span>,15);
<span class="keyword">for</span> k = 1:length(smalldist)
   line([smallsoln(smallI(k),1) smallsoln(smallJ(k),1)], <span class="keyword">...</span>
      [smallsoln(smallI(k),2) smallsoln(smallJ(k),2)]);
<span class="keyword">end</span>
axis([0 1 0 1],<span class="string">'square'</span>);
title(<span class="string">'original'</span>);
<span class="comment">% Second illustration.</span>
subplot(2,2,2);
plot(1+smallsoln(:,1),2+smallsoln(:,2),<span class="string">'g.'</span>,<span class="string">'MarkerSize'</span>,15);
<span class="keyword">for</span> k = 1:length(smalldist)
   line([1+smallsoln(smallI(k),1) 1+smallsoln(smallJ(k),1)], <span class="keyword">...</span>
      [2+smallsoln(smallI(k),2) 2+smallsoln(smallJ(k),2)]);
<span class="keyword">end</span>
axis([1 2 2 3],<span class="string">'square'</span>);
title(<span class="string">'translated'</span>);
<span class="comment">% Third illustration.</span>
subplot(2,2,3);
plot(smallsoln(:,2),-smallsoln(:,1),<span class="string">'g.'</span>,<span class="string">'markersize'</span>,15);
<span class="keyword">for</span> k = 1:length(smalldist)
   line([smallsoln(smallI(k),2) smallsoln(smallJ(k),2)], <span class="keyword">...</span>
      [-smallsoln(smallI(k),1) -smallsoln(smallJ(k),1)]);
<span class="keyword">end</span>
axis([0 1 -1 0],<span class="string">'square'</span>);
title(<span class="string">'rotated'</span>);
<span class="comment">% Fourth illustration.</span>
subplot(2,2,4);
pts = plot(1-smallsoln(:,1),smallsoln(:,2),<span class="string">'g.'</span>);
set(pts,<span class="string">'markersize'</span>,15);
<span class="keyword">for</span> k = 1:length(smalldist)
   line([1-smallsoln(smallI(k),1) 1-smallsoln(smallJ(k),1)], <span class="keyword">...</span>
      [smallsoln(smallI(k),2) smallsoln(smallJ(k),2)]);
<span class="keyword">end</span>
axis([0 1 0 1],<span class="string">'square'</span>);
title(<span class="string">'reflected'</span>);
</pre><img vspace="5" hspace="5" src="../molecule_03.png" alt=""> <p>25 個の原子の例を解いてみましょう。スパース行列 S は 25 x 25 の表です。S の非ゼロ要素はそれぞれ、原子の既知のペア間距離に対応します。</p><pre class="codeinput">[I,J,dist] = find(S);
subplot(1,1,1);
spy(S+S');
title(<span class="string">'Measured distances'</span>);
</pre><img vspace="5" hspace="5" src="../molecule_04.png" alt=""> <p>MMOLE は、原子の現在の位置とスパース距離行列 (ゴール) を入力とし、関数の現在の値 (誤差)、その勾配、およびそのスパース ヘッセ行列を返します。</p><p>H はスパース行列であるため、大規模な最適化アルゴリズムを使用してこの最適化問題を解くことができます。</p><pre class="codeinput">[val,g,H] = mmole(xstart,S);
spy(H);
title(<span class="string">'Structure of Hessian Matrix'</span>);
</pre><img vspace="5" hspace="5" src="../molecule_05.png" alt=""> <p>これは、ランダムな開始位置における原子のプロットです。開始距離とターゲット距離との誤差が色付きで示されています。</p><p>いくつかのエッジが黄色または赤色であることに注意してください。これは、現在の位置と実験データとの間に大きな相違があることを示しています。目的は、これらの誤差を最小化することです。</p><pre class="codeinput">xstart = [ [.25 .25]; [.25 .75]; [.75 .25]; reshape(xstart,N-3,2)];
pts = plot(xstart(:,1),xstart(:,2),<span class="string">'g.'</span>); set(pts,<span class="string">'Markersize'</span>,15);
<span class="keyword">for</span> k = 1:length(dist)
   energy(k) = (dist(k)^2 - norm(xstart(I(k),:) - xstart(J(k),:))^2)^2;
<span class="keyword">end</span>

colormap(energscale);
numcolors = size(energscale,1);
<span class="keyword">for</span> k = 1:length(dist)
   line([xstart(I(k),1) xstart(J(k),1)],[xstart(I(k),2) xstart(J(k),2)], <span class="keyword">...</span>
      <span class="string">'Color'</span>,energscale(min(numcolors,max(1,ceil(numcolors*energy(k)))),:));
<span class="keyword">end</span>
title(<span class="string">'Initial locations and error distribution'</span>);
axis <span class="string">square</span>;
colorbar;
</pre><img vspace="5" hspace="5" src="../molecule_06.png" alt=""> <p>まず、最適化関数 FMINUNC のオプションを設定します。mmole.m で計算されている勾配とヘッセ行列を使用し、最終的な統計レポートと反復進行状況を表示するように指示します。</p><p>次に、最適化ルーチン FMINUNC を開始します。このルーチンは、この問題を解くために約 40 回の反復を実行します。</p><pre class="codeinput">xstart = reshape(xstart(4:N,:),2*N-6,1);
options = optimset(<span class="string">'largescale'</span>,<span class="string">'on'</span>, <span class="string">'gradobj'</span>,<span class="string">'on'</span>, <span class="string">'hessian'</span>,<span class="string">'on'</span>, <span class="keyword">...</span>
   <span class="string">'display'</span>,<span class="string">'none'</span>,<span class="string">'outputfcn'</span>,@moleculeoutputfcn);
x = fminunc(@mmole,xstart,options,S);
</pre><img vspace="5" hspace="5" src="../molecule_07.png" alt=""> <img vspace="5" hspace="5" src="../molecule_08.png" alt=""> <p>このプロットは、最終位置における原子を示しています。線の色がすべて灰色であることに注意してください。これは、これらの線がすべて、S によって与えられたターゲット距離にほぼ一致することを意味します。</p><pre class="codeinput"><span class="comment">% Close figures that FMINUNC creates (if they are still open).</span>
delete(findobj(0,<span class="string">'Name'</span>,<span class="string">'Algorithm Performance Statistics'</span>))
delete(findobj(0,<span class="string">'Name'</span>,<span class="string">'Progress Information'</span>))
<span class="comment">% Plot atoms in final positions.</span>
subplot(1,1,1)
xsol = [ [.25 .25]; [.25 .75]; [.75 .25]; reshape(x,N-3,2)];
pts = plot(xsol(:,1),xsol(:,2),<span class="string">'g.'</span>); set(pts,<span class="string">'markersize'</span>,15);
<span class="keyword">for</span> k = 1:length(dist)
   energy(k) = (dist(k)^2 - norm(xsol(I(k),:) - xsol(J(k),:))^2)^2;
<span class="keyword">end</span>
maxenergy = max(energy);
colormap(energscale);
numcolors = size(energscale,1);
<span class="keyword">for</span> k = 1:length(dist)
   line([xsol(I(k),1) xsol(J(k),1)],[xsol(I(k),2) xsol(J(k),2)], <span class="keyword">...</span>
      <span class="string">'Color'</span>,energscale(min(numcolors,max(1,ceil(numcolors*energy(k)))),:));
<span class="keyword">end</span>
title(<span class="string">'Final error distribution for pairs in S'</span>);
axis([min(xsol(:,1)),max(xsol(:,1)),min(xsol(:,2)),max(xsol(:,2))]);
axis <span class="string">square</span>;
colorbar;
</pre><img vspace="5" hspace="5" src="../molecule_09.png" alt=""> <p>初期構成と最終構成を比較してみましょう。</p><pre class="codeinput">subplot(1,2,1);
xstart = [ [.25 .25]; [.25 .75]; [.75 .25]; reshape(xstart,N-3,2)];
pts = plot(xstart(:,1),xstart(:,2),<span class="string">'g.'</span>); set(pts,<span class="string">'Markersize'</span>,15);
<span class="keyword">for</span> k = 1:length(dist)
   energy(k) = (dist(k)^2 - norm(xstart(I(k),:) - xstart(J(k),:))^2)^2;
<span class="keyword">end</span>
colormap(energscale);
numcolors = size(energscale,1);
<span class="keyword">for</span> k = 1:length(dist)
   line([xstart(I(k),1) xstart(J(k),1)],[xstart(I(k),2) xstart(J(k),2)], <span class="keyword">...</span>
      <span class="string">'Color'</span>,energscale(min(numcolors,max(1,ceil(numcolors*energy(k)))),:));
<span class="keyword">end</span>
title(<span class="string">'Initial'</span>);
axis <span class="string">square</span>;
colorbar;
subplot(1,2,2);
pts = plot(xsol(:,1),xsol(:,2),<span class="string">'g.'</span>); set(pts,<span class="string">'markersize'</span>,15);
<span class="keyword">for</span> k = 1:length(dist)
   energy(k) = (dist(k)^2 - norm(xsol(I(k),:) - xsol(J(k),:))^2)^2;
<span class="keyword">end</span>
maxenergy = max(energy);
colormap(energscale);
numcolors = size(energscale,1);
<span class="keyword">for</span> k = 1:length(dist)
   line([xsol(I(k),1) xsol(J(k),1)],[xsol(I(k),2) xsol(J(k),2)], <span class="keyword">...</span>
      <span class="string">'Color'</span>,energscale(min(numcolors,max(1,ceil(numcolors*energy(k)))),:));
<span class="keyword">end</span>
title(<span class="string">'Final'</span>);
axis([min(xsol(:,1)),max(xsol(:,1)),min(xsol(:,2)),max(xsol(:,2))],<span class="string">'square'</span>);
colorbar;
</pre><img vspace="5" hspace="5" src="../molecule_10.png" alt=""> <p class="footer">Copyright 1990-2007 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Large-Scale Unconstrained Nonlinear Minimization % This demonstration uses the large-scale functionality in the Optimization Toolbox(TM) % to solve a two-dimensional Molecule Conformation Problem.  This type % of problem also arises in other applications including satellite ranging and % surveying.  % Copyright 1990-2007 The MathWorks, Inc. % $Revision: 1.1.4.12.2.1 $ $Date: 2010/07/29 21:28:56 $  %% % MOLECULE CONFORMATION PROBLEM: % Arrange the N atoms of a molecule in a way that the distances between % specified pairs of atoms match experimental data.  %  % A simple example is shown above.  The data is on the left and the solution on % the right.  load molecule; [smallI,smallJ,smalldist] = find(smallS); subplot(1,2,1); for i = 1:length(smalldist)    line([0,smalldist(i)],[i i]);    text(-0.07,i,sprintf('%d',smallJ(i)));    text(smalldist(i)+.02,i,sprintf('%d',smallI(i))); end axis([-.1 1 0 10],'off'); title('Measured distances between Pairs'); subplot(1,2,2); plot(smallsoln(:,1),smallsoln(:,2),'g.','MarkerSize',15); for i = 1:length(smalldist),    line([smallsoln(smallI(i),1) smallsoln(smallJ(i),1)], ...       [smallsoln(smallI(i),2) smallsoln(smallJ(i),2)]); end textpos = smallsoln + [-.09 0;-.08 .08;.04 .01;.04 0;.03 -.07;.03 .07]; for i = 1:6    text(textpos(i,1),textpos(i,2),sprintf('%d',i)); end axis([-0.1 1 0 1.1],'off','square'); title('Atom Locations');  %% % An optimization approach to this problem is to start off with a random % configuration (shown above) and move the atoms until the configuration with % the smallest error is found.  Specifically, given locations for the atoms: % %     X = [x(1:N) y(1:N)]'; % % we associate an error (norm(X(i,:)-X(j,:))^2 - S(i,j)^2)^2 to each pair (i,j) % in the set of measured data S. The total error, given by MMOLE(X,S), is the % sum of the errors of all pairs in S.  We will find a local minimizer for the % error function MMOLE.  N = 25; [I,J,dist] = find(S); Xstart = [ [.25 .25]; [.25 .75]; [.75 .25]; reshape(xstart,N-3,2) ];  subplot(1,1,1); plot(Xstart(:,1),Xstart(:,2),'g.','Markersize',18); for k = 1:length(dist)    line([Xstart(I(k),1) Xstart(J(k),1)],[Xstart(I(k),2) Xstart(J(k),2)]); end title('Initial Locations'); axis square;  %% % Distances are invariant under rigid motion; translations, rotations and % reflections do not effect the error function MMOLE. %  % In order to avoid such motions, we assume that the locations of three of the % atoms are known. Since these locations are fixed, we will actually work with % only 2N-6 unknowns.  % First illustration. subplot(2,2,1); plot(smallsoln(:,1),smallsoln(:,2),'g.','MarkerSize',15); for k = 1:length(smalldist)    line([smallsoln(smallI(k),1) smallsoln(smallJ(k),1)], ...       [smallsoln(smallI(k),2) smallsoln(smallJ(k),2)]); end axis([0 1 0 1],'square'); title('original'); % Second illustration. subplot(2,2,2); plot(1+smallsoln(:,1),2+smallsoln(:,2),'g.','MarkerSize',15); for k = 1:length(smalldist)    line([1+smallsoln(smallI(k),1) 1+smallsoln(smallJ(k),1)], ...       [2+smallsoln(smallI(k),2) 2+smallsoln(smallJ(k),2)]); end axis([1 2 2 3],'square'); title('translated'); % Third illustration. subplot(2,2,3); plot(smallsoln(:,2),-smallsoln(:,1),'g.','markersize',15); for k = 1:length(smalldist)    line([smallsoln(smallI(k),2) smallsoln(smallJ(k),2)], ...       [-smallsoln(smallI(k),1) -smallsoln(smallJ(k),1)]); end axis([0 1 -1 0],'square'); title('rotated'); % Fourth illustration. subplot(2,2,4); pts = plot(1-smallsoln(:,1),smallsoln(:,2),'g.'); set(pts,'markersize',15); for k = 1:length(smalldist)    line([1-smallsoln(smallI(k),1) 1-smallsoln(smallJ(k),1)], ...       [smallsoln(smallI(k),2) smallsoln(smallJ(k),2)]); end axis([0 1 0 1],'square'); title('reflected');  %% % Let's solve an example with 25 atoms.  The sparse matrix S is a 25 x 25 % table.  Each nonzero entry in S corresponds to a known distance between a pair % of atoms.  [I,J,dist] = find(S); subplot(1,1,1); spy(S+S'); title('Measured distances');  %% % MMOLE takes the current positions of the atoms and the sparse distance matrix % (the goal), and returns the distance function's current value (the error), its % gradient, and its sparse Hessian. % % Because H is sparse we can use a large-scale optimization algorithm to solve % this optimization problem.  [val,g,H] = mmole(xstart,S); spy(H); title('Structure of Hessian Matrix');  %% % This is a plot of the atoms in their random starting locations. The error % between the starting distances and the target distances is indicated by the % color. %  % Observe that several edges have a yellow or red color.  This indicates there % is a big discrepancy between the current locations and the experimental data. % Our goal is to minimize these errors.  xstart = [ [.25 .25]; [.25 .75]; [.75 .25]; reshape(xstart,N-3,2)]; pts = plot(xstart(:,1),xstart(:,2),'g.'); set(pts,'Markersize',15); for k = 1:length(dist)    energy(k) = (dist(k)^2 - norm(xstart(I(k),:) - xstart(J(k),:))^2)^2; end  colormap(energscale); numcolors = size(energscale,1); for k = 1:length(dist)    line([xstart(I(k),1) xstart(J(k),1)],[xstart(I(k),2) xstart(J(k),2)], ...       'Color',energscale(min(numcolors,max(1,ceil(numcolors*energy(k)))),:)); end title('Initial locations and error distribution'); axis square; colorbar;  %% % First we set the options for the optimization function FMINUNC.  We tell it to % use the gradient and Hessian calculated in mmole.m and show us a final % statistics report and iteration progress information. %  % Then, we start the optimization routine FMINUNC, which takes about 40 % iterations to solve this problem.  xstart = reshape(xstart(4:N,:),2*N-6,1); options = optimset('largescale','on', 'gradobj','on', 'hessian','on', ...    'display','none','outputfcn',@moleculeoutputfcn); x = fminunc(@mmole,xstart,options,S);  %% % This plot shows the atoms in their final positions.  Observe that all the line % colors are gray.  This means they are all closely matching the target % distances given by S.  % Close figures that FMINUNC creates (if they are still open). delete(findobj(0,'Name','Algorithm Performance Statistics')) delete(findobj(0,'Name','Progress Information')) % Plot atoms in final positions. subplot(1,1,1) xsol = [ [.25 .25]; [.25 .75]; [.75 .25]; reshape(x,N-3,2)]; pts = plot(xsol(:,1),xsol(:,2),'g.'); set(pts,'markersize',15); for k = 1:length(dist)    energy(k) = (dist(k)^2 - norm(xsol(I(k),:) - xsol(J(k),:))^2)^2; end maxenergy = max(energy); colormap(energscale); numcolors = size(energscale,1); for k = 1:length(dist)    line([xsol(I(k),1) xsol(J(k),1)],[xsol(I(k),2) xsol(J(k),2)], ...       'Color',energscale(min(numcolors,max(1,ceil(numcolors*energy(k)))),:)); end title('Final error distribution for pairs in S'); axis([min(xsol(:,1)),max(xsol(:,1)),min(xsol(:,2)),max(xsol(:,2))]); axis square; colorbar;  %% % Let's compare the initial and final configuration.  subplot(1,2,1); xstart = [ [.25 .25]; [.25 .75]; [.75 .25]; reshape(xstart,N-3,2)]; pts = plot(xstart(:,1),xstart(:,2),'g.'); set(pts,'Markersize',15); for k = 1:length(dist)    energy(k) = (dist(k)^2 - norm(xstart(I(k),:) - xstart(J(k),:))^2)^2; end colormap(energscale);  numcolors = size(energscale,1); for k = 1:length(dist)    line([xstart(I(k),1) xstart(J(k),1)],[xstart(I(k),2) xstart(J(k),2)], ...       'Color',energscale(min(numcolors,max(1,ceil(numcolors*energy(k)))),:)); end title('Initial'); axis square; colorbar; subplot(1,2,2); pts = plot(xsol(:,1),xsol(:,2),'g.'); set(pts,'markersize',15); for k = 1:length(dist)    energy(k) = (dist(k)^2 - norm(xsol(I(k),:) - xsol(J(k),:))^2)^2; end maxenergy = max(energy);  colormap(energscale); numcolors = size(energscale,1); for k = 1:length(dist)    line([xsol(I(k),1) xsol(J(k),1)],[xsol(I(k),2) xsol(J(k),2)], ...       'Color',energscale(min(numcolors,max(1,ceil(numcolors*energy(k)))),:)); end title('Final'); axis([min(xsol(:,1)),max(xsol(:,1)),min(xsol(:,2)),max(xsol(:,2))],'square'); colorbar;   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>